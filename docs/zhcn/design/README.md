# SRaft 的设计

## 架构设计

### 1 各层协议分离

从开始构造整个 SRaft 的时候，我就意识到了一个无比困难的问题：我的时间和精力都是有限的，但是我期望 `SRaft` 可以拥有强大的能力。
但是由于时间有限，短时间内我必然无法完美实现我的目标，因此我保留了 RAFT 的基本设计，在此基础上，我将不同层次的实现进行抽象，实现分层。

在 `Raft` 中，作者使用了 `RPC` 技术，但在通读论文后，我意识到一个问题，其实作者也许只是希望能够简单的调用其他 `Server` 的方法。
至于到底该怎样调用，`Raft` 并没有可以关注。
所以，我将整个 `RPC` 的实现完全抽象，在仓库 `pkg/plugins/point` 目录下。
同时，存储结构和能力在不同的场景下也许会有完全不同的需求，因此使用类似的手法将存储层也抽离了出来。
其目录在仓库 `pkg/plugins/storage` 下。后文会详细的描述抽象的目标和实现逻辑。

#### 1.1 Point 网络层抽象
在 `SRaft` 中，RPC 的实现转交给抽象结构：`Point`。
包括对外提供服务和对内的远程调用，每个 `Server` 都需要明确自己使用的 `Point` 的种类的版本。

每个 `Point` 都可以生成 `Server` 和 `Client` 两种对象（或结构体？）。
它们需要满足一下条件：
- 相同类型的 `Client` 和 `Server` 在使用配套的配置后，可以正常通信。
- 不同类型的 `Client` 和 `Server` 不保证正常通信。
- 两个相同类型的 `Client`（或 `Server`）使用相同的配置后，其能力是完全一样的。

`Point` 本质上是对网络协议的一种抽象，同通过不同的协议来实现。
`Point` 本身不要求鉴权行为，也不保证数据一致性。
在不同场景下，如果有安全要求，可以在 `pkg/plugins/point` 实现一套满足使用者需求的安全通信实现。
实现方法可见[扩展网路协议](../extend/extend_point.md)。


#### 1.2 Storage 存储层抽象
